#include <stdio.h> 
#include <stdlib.h> 
#include <locale.h>

int main(int argc, char* argv[])
{
	setlocale(LC_ALL, "Rus");

	int i = 0;    //Индекс массивов
	int n = 0;    //Кол-во чисел
	int x = 0;    //Нужна для работы с массивом, ей мы будем присваивать случайные числа
	int* flag;
	double* massiv;    //Указатель на массив изнач. чисел
	double* drob;    //Указатель на массив дробных частей
	double SUM = 0.0;    //Конечная сумма, кот. нужно будет подсчитать

	double max = 0;     //Максимальное и миимальное значения
	double min = 0;

	//В том случае, если мы ввели в cmd меньше четырёх аргументов
	if (argc < 4)
	{
		printf("Недостаточное количество аргументов, пожалуйста, введите минимум три аргумента\n");
		return 1;
	}
	n = atoi(argv[1]);
	min = atof(argv[2]);
	max = atof(argv[3]);

	//Выделяем память под нужные нам массивы
	massiv = (double*)malloc(n * sizeof(double));    //Массив основных чисел
	drob = (double*)malloc(n * sizeof(double));    //Массив дробных частей
	flag = (int*)malloc(n * sizeof(int));    //Массив "маркеров"("Флажков")

	for (i = 0; i < n; i++)    //В этом цикле для каждого индекса ставится в соответствие "флажок", нужный для подсчёта конечной суммы
	{
		flag[i] = 0;
		x = rand();
		massiv[i] = (((double)x) / RAND_MAX) * (max - min) + min;    //Здесь формируется массив из случайных чисел в диапазоне от min до max

		drob[i] = (massiv[i] - (int)massiv[i]);    //Здесь вычисляется дробная часть каждого из полученных чисел

		switch (n) 
		{
			case ((n > 0) && (n <= 10)):
				drob[i] = (drob[i] * 10);
				break;
			case ((n > 10) && (n <= 100)) :
				drob[i] = (drob[i] * 100);
				break;
			case ((n > 100) && (n <= 1000)) :
				drob[i] = (drob[i] * 1000);
				break;
			case ((n > 1000) && (n <= 10000)) :
				drob[i] = (drob[i] * 10000);
				break;
			case ((n > 10000) && (n <= 100000)) :
				drob[i] = (drob[i] * 100000);
				break;
			case ((n > 100000) && (n <= 1000000)) :
				drob[i] = (drob[i] * 1000000);
				break;
		}

		drob[i] = (int)drob[i];    //...а затем приводится к целочисленному виду, дабы мы могли сравнивать её с номерами чисел
		printf("%d: %lf - %lf\n", i, massiv[i], drob[i]);    //Здесь на экран выводятся индекс числа, само число и его дробная часть

	}

	for (i = 0; i < n; i++)  //В этом цикле наша программа будет считать искомую сумму
	{
		SUM += massiv[i];    //Сначала по умолчанию складываем все числа
		if (((int)drob[i] < n) && (flag[(int)drob[i]] == 0))    //Затем, если все дробные части чисел меньше кол-ва этих чисел и "флажок" ещё не использован, вычитаем дважды те числа, у кот. индекс совп. с дроб. частью какого-нибудь из чисел
		{
			SUM -= 2 * massiv[(int)drob[i]];    //Вычитаем их дважды, поскольку мы их сначала уже прибавили
			flag[(int)drob[i]] = 1;    //Устанавливем "флажок", показывая, что это число уже было использовано
		}
	}
	printf("Сумма равна: %lf\n", SUM);    //Выводим на экран искомую сумму
	return 0;
}